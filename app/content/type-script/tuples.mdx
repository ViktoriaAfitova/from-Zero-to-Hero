---
title: Tuples
---

Кортежи (Tuples) также, как и массивы, представляют набор элементов, для которых уже заранее известен тип. В отличие от массивов кортежи могут хранить значения разных типов. Для определения кортежа применяется синтаксис массива:

```typescript
let user: [string, number];
```

В приведенном примере кортеж user представляет тип [string, number], то есть кортеж, состоящий из двух элементов, где первый элемент имеет тип string, а второй элемент имеет тип number.

- Значения для кортежа присваиваются с использованием массива:

```typescript
user = ['Tom', 28];
```

- Передаваемые значения должны соответствовать типам элементов по их позиции. Если типы не совпадают, будет ошибка, например:

```typescript
// Неправильная инициализация - переданные значения не соответствуют типам по позиции
userInfo = [28, 'Tom']; // Ошибка
```

- Для доступа к элементам кортежа используются индексы, так же как и в массивах:

```typescript
let user: [string, number] = ['Tom', 36];
console.log(user[1]); // 36
user[1] = 37;
console.log(user[1]); // 37
```

- Цикл for также может использоваться для перебора элементов кортежа:

```typescript
let user: [string, number] = ['Tom', 36];
for (const prop of user) {
    console.log(prop);
}
```

#### Кортежи могут использоваться в функциях как параметры и результаты.

- в качестве параметра функции:

```typescript
function printUser(user: [string, number]) {
    console.log(user[0]);
    console.log(user[1]);
}
let tom: [string, number] = ['Tom', 36];
printUser(tom);
```

- как результат функции:

```typescript
function createUser(name: string, age: number): [string, number] {
    return [name, age];
}
let user = createUser('Bob', 41);
console.log(user[0]);
console.log(user[1]);
```

#### Кортежи могут содержать необязательные элементы. Для этого после типа элемента ставится вопросительный знак ?.

```typescript
let bob: [string, number, boolean?] = ['Bob', 41, true];
let tom: [string, number, boolean?] = ['Tom', 36];
```

Здесь последний элемент, представляющий тип boolean, является необязательным. Необязательные элементы должны идти в конце кортежа, после обязательных элементов.

#### Декомпозиция кортежа позволяет распаковать его на переменные или константы.

```typescript
let tom: [string, number, boolean] = ['Tom', 36, false];
let [username, userage, isMarried] = tom; // декомпозиция
console.log(username); // 'Tom'
console.log(userage); // 36
console.log(isMarried); // false
```

В данном примере кортеж tom распаковывается на три переменные: username, userage и isMarried. При декомпозиции количество переменных должно соответствовать количеству элементов кортежа.

#### Кортежи также могут иметь неопределенное количество элементов с использованием оператора ... в определении типа кортежа.

```typescript
let math: [string, ...number[]] = ['Math', 5, 4, 5, 4, 4];
let physics: [string, ...number[]] = ['Physics', 5, 5, 5];
```

Оба кортежа math и physics представляют тип [string, ...number[]]. Это означает, что первый элемент кортежа должен быть типа string, а остальные элементы - типа number. Количество элементов может быть неопределенным.

#### Кортежи также могут быть только для чтения, что означает, что их элементы нельзя изменять. Для этого перед типом кортежа указывается ключевое слово readonly:

```typescript
const tom: readonly [string, number] = ['Tom', 36];
tom[1] = 37; // Ошибка - элементы кортежа для чтения нельзя изменять
```

Кортежи с readonly могут использоваться в качестве параметров функций или результатов функций.

Кортежи предоставляют возможность явно указывать типы для каждого элемента набора данных, что обеспечивает строгую типизацию.

[Ссылка](https://metanit.com/web/typescript/2.10.php)