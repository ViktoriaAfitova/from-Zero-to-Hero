import { AccordionItem } from './AccordionItem';

interface AccordionData {
  title: string;
  content: string;
}

const accordionData: AccordionData[] = [
  {
    title: 'Data Types',
    content:
      '1. String 2. Number 3. Bigint 4. Boolean 5. Undefined 6. Null 7. Symbol 8. Object . Объект (Object): состоит из коллекции пар "ключ-значение" и может содержать любые типы данных в качестве значений. Примитивные типы данных в JavaScript хранятся по значению (value types), тогда как объекты хранятся по ссылке (reference types). Это означает, что при присваивании примитивного значения создается копия значения, а при присваивании объекта создается копия ссылки на объект.',
  },
  {
    title: 'Use Strict',
    content:
      'Strict mode включает более строгую интерпретацию и проверку кода, код выполняется в соответствии с современными стандартами языка JavaScript. 1. Заменяет исключениями некоторые ошибки. 2. Исправляет ошибки, которые мешали движкам JS выполнять оптимизацию ("eval" или "arguments.caller"). 3. Запрещает использовать некоторые элементы синтаксиса.',
  },
  {
    title: 'SOLID',
    content:
      'SOLID - аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании. Single responsibility — принцип едининой ответственности. Модуль должен отвечать за что-то одно. Open-closed — принцип открытости / закрытости. Модуль открыт для расширения и закрыт для изменения.     Liskov substitution — принцип подстановки Барбары Лисков. Цель, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Interface segregation — принцип разделения интерфейса. Модули не должны зависеть от интерфейсов, которые не используют. Dependency inversion — принцип инверсии зависимостей. Модули верхних уровней не должны зависеть от модулей нижних уровней',
  },
  {
    title: 'defer/async',
    content:
      'Это атрибуты, которые можно добавить к тегу <script> в HTML для управления способом загрузки и выполнения скриптов. 1. defer: указывает браузеру, что скрипт будет загружаться параллельно с загрузкой страницы, но выполнение скрипта должно быть отложено до тех пор, пока вся страница не будет полностью загружена. Скрипты с атрибутом defer сохраняют относительный порядок выполнения в соответствии с порядком их появления в HTML-документе 2. async: указывает браузеру, что скрипт может быть выполнен асинхронно с загрузкой страницы. Браузер загружает и выполняет скрипт параллельно с другими операциями и не ожидает завершения загрузки скрипта перед продолжением парсинга страницы. Скрипты с атрибутом async могут выполняться в любом порядке.',
  },
  {
    title: 'Arrow function vs Function',
    content:
      '1. синтаксис 2. лексическое значение this (у стрелочных ф-ций нет своего this, если идёт обращение к нему, то берётся снаружи) 3. не имеют arguments 4. не могут быть вызваны с оператором new в качестве конструктора',
  },
  {
    title: 'Closure',
    content:
      'Лексическое окружение (lexical environment) и глобальное окружение (global environment) - это концепции, связанные с областью видимости и доступностью переменных в JS. 1. Лексическое окружение: Лексическое окружение связано с областью видимости функции и определяется местом, где функция была определена в исходном коде. Каждая функция имеет своё лексическое окружение, которое содержит ссылку на внешнее окружение (родительское окружение) и локальные переменные функции. 2. Глобальное окружение: Глобальное окружение - окружение верхнего уровня, которое существует в глобальной области видимости. Оно содержит все глобальные переменные и функции, доступные в программе. Глобальное окружение также имеет ссылку на внешнее окружение, которая обычно равна null, так как глобальное окружение не находится внутри другой функции. 3. Создание нового окружения: в JavaScript новое окружение создается при вызове функции. Каждый вызов функции создает новый экземпляр лексического окружения для этого вызова. При создании нового окружения, функция получает доступ к своим локальным переменным и параметрам, а также к переменным из внешнего окружения (родительского окружения) благодаря ссылке на него. 4. Поиск переменных в окружении: При поиске значения переменной JavaScript сначала ищет её в текущем лексическом окружении. Если переменная не найдена, поиск продолжается во внешнем окружении (родительском окружении), и так далее, пока не будет достигнуто глобальное окружение. Если переменная не найдена ни в одном из окружений, будет возвращено значение undefined.',
  },
  {
    title: 'IIFE',
    content:
      'Immediatly Invoked Function Expression (немедленно вызываемое функциональное выражение). Самовызывающаяся функция обеспечивает коду собственный блок видимости',
  },
  { title: 'Falsy', content: 'false, "", 0, null, undefined, NaN, Bigint' },
  {
    title: 'var, let, const',
    content:
      'var - глобальная или ф-ная область видимости; let, const - блочная область видимости. Var могут быть обновлены и переопределены, поднятие наверх undefined, можно объявить и не инициализировать. Let могут быть обновлены, но не могут быть переопределены, поднятие наверх ReferenceError, можно объявить и не инициализировать. Const - не могут быть обновлены или переопределены, поднятие наверх ReferenceError, необходимо инициализировать во время объявления',
  },
  {
    title: 'Map & Set',
    content:
      'Map - коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа. Для работы с Map доступны методы для добавления, удаления, получения элементов, а также определения размера Map и проверки наличия элемента по ключу (set, delete, get, size, has). Set - особый вид коллекции: "множество" значений (без ключей), своего рода массив, где каждое значение может появляться только один раз.',
  },
];

export const Accordion = () => {
  return (
    <div className='accordion'>
      {accordionData.map((item) => (
        <AccordionItem
          key={item.title}
          title={item.title}
          content={item.content}
        />
      ))}
    </div>
  );
};
